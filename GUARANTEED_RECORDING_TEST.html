<!DOCTYPE html>
<html>
<head>
    <title>Guaranteed Recording Test</title>
    <style>
        body { font-family: Arial; max-width: 800px; margin: 50px auto; padding: 20px; }
        button { padding: 15px 30px; margin: 10px; font-size: 16px; cursor: pointer; }
        .start { background: #28a745; color: white; border: none; border-radius: 5px; }
        .stop { background: #dc3545; color: white; border: none; border-radius: 5px; }
        video { width: 100%; max-width: 640px; border: 2px solid #333; margin: 20px 0; }
        #status { padding: 15px; background: #f8f9fa; border-radius: 5px; margin: 15px 0; }
        .success { background: #d4edda !important; color: #155724; }
        .error { background: #f8d7da !important; color: #721c24; }
        #log { background: #000; color: #0f0; padding: 15px; font-family: monospace; height: 300px; overflow-y: scroll; }
    </style>
</head>
<body>
    <h1>üé• Guaranteed Recording Test</h1>
    <p><strong>This will definitely work if your camera/mic are functional.</strong></p>
    
    <div id="status">Ready to test</div>
    
    <button class="start" onclick="startTest()">‚ñ∂Ô∏è Start Test Recording</button>
    <button class="stop" onclick="stopTest()" disabled id="stopBtn">‚èπÔ∏è Stop Test</button>
    
    <h3>Live Preview:</h3>
    <video id="preview" autoplay muted></video>
    
    <h3>Console Log:</h3>
    <div id="log"></div>
    
    <div id="downloadSection" style="display:none; margin-top: 20px;">
        <h3>‚úÖ Recording Complete!</h3>
        <a id="downloadLink" style="padding: 15px 30px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; display: inline-block;">
            üì• Download Recording
        </a>
        <p>File size: <span id="fileSize"></span></p>
    </div>
    
    <script>
        let mediaRecorder, recordedChunks = [], stream;
        
        function log(msg, isError = false) {
            const time = new Date().toLocaleTimeString();
            const color = isError ? '#f00' : '#0f0';
            document.getElementById('log').innerHTML += `<div style="color: ${color}">[${time}] ${msg}</div>`;
            document.getElementById('log').scrollTop = document.getElementById('log').scrollHeight;
            console.log(msg);
        }
        
        function updateStatus(msg, className = '') {
            const el = document.getElementById('status');
            el.textContent = msg;
            el.className = className;
        }
        
        async function startTest() {
            try {
                log('üé• Requesting camera and microphone access...');
                updateStatus('Requesting permissions...', '');
                
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 1280, height: 720 },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                log('‚úÖ Camera and microphone access granted!');
                document.getElementById('preview').srcObject = stream;
                
                const options = {
                    mimeType: MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus') 
                        ? 'video/webm;codecs=vp9,opus' 
                        : 'video/webm',
                    videoBitsPerSecond: 2500000,
                    audioBitsPerSecond: 128000
                };
                
                log(`üìπ Creating MediaRecorder with: ${options.mimeType}`);
                mediaRecorder = new MediaRecorder(stream, options);
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = (e) => {
                    if (e.data && e.data.size > 0) {
                        recordedChunks.push(e.data);
                        log(`üì¶ Chunk ${recordedChunks.length}: ${e.data.size} bytes`);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    log('üõë Recording stopped, creating download...');
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    
                    const downloadLink = document.getElementById('downloadLink');
                    downloadLink.href = url;
                    downloadLink.download = `test-recording-${Date.now()}.webm`;
                    
                    document.getElementById('fileSize').textContent = 
                        `${(blob.size / (1024 * 1024)).toFixed(2)} MB`;
                    
                    document.getElementById('downloadSection').style.display = 'block';
                    
                    log(`‚úÖ Recording complete! Size: ${(blob.size / (1024 * 1024)).toFixed(2)} MB`);
                    updateStatus('‚úÖ Recording complete! Download link ready.', 'success');
                };
                
                mediaRecorder.onerror = (e) => {
                    log(`‚ùå MediaRecorder error: ${e.error}`, true);
                    updateStatus('‚ùå Recording error', 'error');
                };
                
                mediaRecorder.start(1000); // 1 second chunks
                log('üî¥ Recording started! Speak now...');
                updateStatus('üî¥ Recording in progress... (Speak for 10 seconds)', 'success');
                
                document.querySelector('.start').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
                // Auto-stop after 10 seconds
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        log('‚è∞ 10 seconds reached, auto-stopping...');
                        stopTest();
                    }
                }, 10000);
                
            } catch (error) {
                log(`‚ùå Error: ${error.name} - ${error.message}`, true);
                updateStatus(`‚ùå Error: ${error.message}`, 'error');
                
                if (error.name === 'NotAllowedError') {
                    alert('‚ùå Camera/Microphone access denied!\n\nPlease:\n1. Click the camera icon in address bar\n2. Change to "Allow"\n3. Refresh and try again');
                } else {
                    alert(`Error: ${error.message}`);
                }
            }
        }
        
        function stopTest() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                log('üõë Stopping recording...');
                mediaRecorder.stop();
                
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    log('üìπ Camera/microphone released');
                }
                
                document.querySelector('.start').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('preview').srcObject = null;
            }
        }
        
        log('‚úÖ Test page loaded and ready');
        log('üëâ Click "Start Test Recording" button to begin');
    </script>
</body>
</html>


