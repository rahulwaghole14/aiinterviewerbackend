<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Interview Portal</title>
    {% load static %}
    <!-- Add Monaco Editor CDN -->
    <link rel="stylesheet" data-name="vs/editor/editor.main" href="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs/editor/editor.main.css">
    <style>
        :root { 
            --primary-color: #667eea; 
            --primary-dark: #5a6fd8;
            --success-color: #28a745; 
            --danger-color: #dc3545; 
            --warning-color: #ffc107;
            --text-primary: #2c3e50;
            --text-secondary: #6c757d;
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --border-color: #e9ecef;
            --shadow: 0 4px 20px rgba(0,0,0,0.1);
            --shadow-hover: 0 8px 30px rgba(0,0,0,0.15);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            line-height: 1.6; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: var(--text-primary);
        }
        
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px;
        }
        
        .card { 
            background: var(--bg-secondary); 
            padding: 2.5rem; 
            border-radius: 20px; 
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }
        
        .card:hover {
            box-shadow: var(--shadow-hover);
            transform: translateY(-2px);
        }
        
        h1, h2, h3 { 
            color: var(--text-primary); 
            margin-bottom: 1rem;
            font-weight: 600;
        }
        
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .btn { 
            display: inline-block; 
            padding: 12px 24px; 
            border-radius: 12px; 
            text-align: center; 
            cursor: pointer; 
            border: none; 
            font-size: 1rem; 
            font-weight: 600; 
            transition: all 0.3s ease;
            text-decoration: none;
            position: relative;
            overflow: hidden;
        }
        
        .btn:disabled { 
            background-color: #ccc; 
            cursor: not-allowed;
            transform: none !important;
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
        }
        
        .submit-btn { 
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark)); 
            color: white; 
        }
        
        .done-btn { 
            background: linear-gradient(135deg, var(--success-color), #20c997); 
            color: white; 
            margin-top: 1rem; 
        }
        
        .cancel-btn { 
            background: linear-gradient(135deg, #6c757d, #495057); 
            color: white; 
        }
        
        .spoken-phase-layout { 
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 2rem;
            align-items: start;
        }
        
        .interview-main { 
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: var(--shadow);
        }
        
        .proctoring-sidebar { 
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            position: sticky;
            top: 20px;
        }
        
        #camera-check-feed, #proctoring-feed { 
            width: 100%; 
            height: auto; 
            border-radius: 15px; 
            background-color: #000; 
            aspect-ratio: 4 / 3;
            box-shadow: var(--shadow);
        }
        
        #verification-feed { 
            width: 100%; 
            max-width: 640px; 
            height: auto; 
            border-radius: 15px; 
            background-color: #000; 
            aspect-ratio: 4 / 3;
            box-shadow: var(--shadow);
        }
        
        .timer-display { 
            font-size: 3rem; 
            font-weight: bold; 
            text-align: center; 
            margin: 2rem 0;
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .warnings-list { 
            list-style: none; 
            padding: 0; 
        }
        
        .warnings-list li { 
            background: linear-gradient(135deg, var(--danger-color), #c82333); 
            color: white; 
            padding: 0.75rem 1.5rem; 
            border-radius: 25px; 
            margin-bottom: 0.75rem; 
            text-align: center; 
            font-weight: 600; 
            font-size: 0.9rem;
            box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .modal-overlay { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0,0,0,0.8); 
            display: none; 
            justify-content: center; 
            align-items: center; 
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content { 
            background: var(--bg-secondary); 
            padding: 3rem; 
            border-radius: 20px; 
            text-align: center; 
            max-width: 500px;
            box-shadow: var(--shadow-hover);
            border: 1px solid var(--border-color);
        }
        
        .question-container {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            border-left: 5px solid var(--primary-color);
        }
        
        .question-category {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-dark));
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            display: inline-block;
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
        
        .question-text {
            font-size: 1.2rem;
            line-height: 1.8;
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .transcription-box {
            background: var(--bg-primary);
            border-radius: 15px;
            padding: 1.5rem;
            margin-top: 1rem;
            border: 2px solid var(--border-color);
            min-height: 100px;
            font-style: italic;
            color: var(--text-secondary);
        }
        
        .coding-container {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: var(--shadow);
        }
        
        .coding-problem {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            border-left: 5px solid var(--warning-color);
        }
        
        .coding-actions {
            display: flex;
            gap: 1rem;
            margin: 1.5rem 0;
            flex-wrap: wrap;
        }
        
        .code-output {
            background: #1e1e1e;
            color: #d4d4d4;
            border-radius: 15px;
            padding: 1.5rem;
            margin-top: 1.5rem;
            font-family: 'Consolas', 'Monaco', monospace;
            border: 2px solid #333;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: blink 1.5s infinite;
        }
        
        .status-loading { background-color: var(--warning-color); }
        .status-success { background-color: var(--success-color); }
        .status-error { background-color: var(--danger-color); }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        @media (max-width: 768px) {
            .spoken-phase-layout {
                grid-template-columns: 1fr;
            }
            
            .container {
                padding: 10px;
            }
            
            .card {
                padding: 1.5rem;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .timer-display {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
<div class="container">
    {% if interview_started %}
        {{ spoken_questions_data|json_script:"spoken-questions-data" }}
        {{ coding_questions_data|json_script:"coding-questions-data" }}

        <!-- Phase 0: Setup Screens -->
        <div id="setup-phase">
            <div id="camera-check-screen" class="card">
                <h1>🎥 Camera & System Check</h1>
                <p style="color: var(--text-secondary); margin-bottom: 2rem;">Please allow camera access. We are making sure everything is ready for your interview.</p>
                <div style="text-align: center;">
                    <img id="camera-check-feed" src="" alt="Camera feed">
                    <p id="camera-check-status" style="font-weight: 600; margin-top: 1rem; padding: 1rem; border-radius: 10px; background: var(--bg-primary);"></p>
                </div>
            </div>
            <div id="id-verification-screen" class="card" style="display: none; text-align: center;">
                <h1>🆔 ID Verification</h1>
                <p style="color: var(--text-secondary); margin-bottom: 2rem;">Please hold your ID card next to your face so both are clearly visible in the frame.</p>
                <div style="max-width: 640px; margin: 0 auto;">
                    <video id="verification-feed" autoplay playsinline style="margin-bottom: 1.5rem;"></video>
                    <button id="capture-id-btn" class="btn submit-btn" style="width: 100%; max-width: 300px;">📸 Capture & Verify ID</button>
                    <p id="id-verification-status" style="font-weight: 600; margin-top: 1rem; padding: 1rem; border-radius: 10px; background: var(--bg-primary);"></p>
                </div>
            </div>
        </div>

        <!-- Phase 1: Spoken Interview -->
        <div id="spoken-interview-phase" class="spoken-phase-layout" data-session-id="{{ interview_session_id }}" style="display: none;">
            <div class="interview-main">
                <h2>🎤 Interview Session</h2>
                <div id="question-container" class="question-container"></div>
                <div id="thinking-timer" class="timer-display" style="display:none;"></div>
                <div id="answering-timer" class="timer-display" style="display:none;"></div>
                <div id="review-timer-display" class="timer-display" style="display:none;"></div>
                <button id="done-btn" class="btn done-btn" style="display:none;">✅ I'm Done Answering</button>
                <div id="transcription-box" class="transcription-box"></div>
            </div>
            <div class="proctoring-sidebar">
                <h3>🔍 Proctoring Monitor</h3>
                <img id="proctoring-feed" src="" alt="Loading...">
                <h4 style="margin-top: 1.5rem; color: var(--text-secondary);">⚠️ Active Warnings</h4>
                <ul id="warnings-list" class="warnings-list"></ul>
            </div>
        </div>

        <!-- Phase 2: Coding Challenge -->
        <div id="coding-interview-phase" style="display: none;">
            <div class="coding-container">
                <h1>💻 Coding Challenge</h1>
                <div id="coding-problem-container" class="coding-problem">
                    <h2 id="coding-question-title" style="margin-top:0; color: var(--primary-color);"></h2>
                    <h3 id="coding-language-display" style="margin-top:0; color: var(--text-secondary);"></h3>
                    <p id="coding-problem-text" style="font-size: 1.1rem; line-height: 1.7;"></p>
                </div>
                <div id="monaco-editor-container" style="width: 100%; height: 400px; border: 2px solid var(--border-color); border-radius: 15px; overflow: hidden;"></div>
                <div class="coding-actions">
                    <button id="run-code-btn" class="btn">▶️ Run Code</button>
                    <button id="submit-code-btn" class="btn submit-btn">🚀 Submit & End Interview</button>
                </div>
                <div id="code-output-container" class="code-output">
                    <h4 style="color: #fff; margin-bottom: 1rem;">📤 Output:</h4>
                    <pre id="code-output-pre" style="white-space: pre-wrap; word-wrap: break-word; margin: 0;"></pre>
                </div>
            </div>
        </div>
    {% endif %}
</div>

<div id="termination-modal" class="modal-overlay">
    <div class="modal-content">
        <h2>⚠️ Absence Detected</h2>
        <p style="color: var(--text-secondary); margin-bottom: 2rem;">The interview will be terminated if you do not return within the time limit.</p>
        <div id="termination-timer" class="timer-display"></div>
        <button id="cancel-termination-btn" class="btn cancel-btn">✅ I'm Back - Continue Interview</button>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs/loader.min.js"></script>
<script>
    const SESSION_KEY = "{{ session_key }}";
    const MOVE_TO_NEXT_AUDIO_URL = "{{ move_to_next_audio_url }}";
    const INTERVIEW_SESSION_ID = "{{ interview_session_id }}";

    const spokenQuestions = JSON.parse(document.getElementById('spoken-questions-data').textContent || '[]');
    const codingQuestions = JSON.parse(document.getElementById('coding-questions-data').textContent || '[]');
    
    let currentSpokenQuestionIndex = -1;
    let currentCodingQuestionIndex = -1;
    let monacoEditor;
    let interviewEnded = false;
    let questionStartTime; 
    let verificationStream;
    let thinkingTimer, answeringTimer, reviewInterval, proctoringInterval, noAnswerTimeout;
    const THINKING_TIME = 20, ANSWERING_TIME = 60, REVIEW_TIME = 10, TERMINATION_TIME = 60;
    let hasStartedSpeaking = false;
    let isTerminationWarningVisible = false, terminationWarningInterval = null;
    let mediaRecorder, audioChunks = [], currentAudio = new Audio(), moveNextAudio = new Audio(MOVE_TO_NEXT_AUDIO_URL), audioContext, micSource, scriptProcessor;
    let silenceDetector = { counter: 0, threshold: 39 };

    document.addEventListener('DOMContentLoaded', () => {
        if (document.getElementById('camera-check-screen')) {
            runCameraCheck();
        }
        document.getElementById('capture-id-btn')?.addEventListener('click', runIdVerification);
        document.getElementById('cancel-termination-btn')?.addEventListener('click', hideTerminationWarning);
    });
    
    // Release media resources when page is about to unload
    window.addEventListener('beforeunload', function() {
        releaseMediaResources();
    });

    async function runCameraCheck() {
        const statusEl = document.getElementById('camera-check-status');
        const feedEl = document.getElementById('camera-check-feed');
        statusEl.innerText = "Initializing camera...";
        try {
            const response = await fetch(`/interview_app/check_camera/?session_key=${SESSION_KEY}`);
            if (!response.ok) { const errData = await response.json(); throw new Error(errData.message || "Server error."); }
            statusEl.innerText = "Camera detected. Waiting for video stream...";
            feedEl.src = `/interview_app/video_feed/?session_key=${SESSION_KEY}&t=${new Date().getTime()}`;
            
            feedEl.onload = async () => {
                statusEl.innerText = "Camera check successful!";
                await fetch("{% url 'release_camera' %}", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_key: SESSION_KEY })
                });
                setTimeout(() => {
                    document.getElementById('camera-check-screen').style.display = 'none';
                    document.getElementById('id-verification-screen').style.display = 'block';
                    startVerificationCamera();
                }, 1000);
            };
            feedEl.onerror = () => { throw new Error("Could not display video feed."); };
        } catch (err) {
            statusEl.innerText = `Error: ${err.message}`;
            statusEl.style.color = "red";
        }
    }
    
    function startVerificationCamera() {
        const videoEl = document.getElementById('verification-feed');
        navigator.mediaDevices.getUserMedia({ video: true })
            .then(stream => {
                verificationStream = stream;
                videoEl.srcObject = stream;
            })
            .catch(err => {
                document.getElementById('id-verification-status').innerText = "Error: Could not access camera.";
            });
    }

    async function runIdVerification() {
        const statusEl = document.getElementById('id-verification-status');
        const videoEl = document.getElementById('verification-feed');
        statusEl.innerText = "Processing, please hold still...";
        
        const canvas = document.createElement('canvas');
        canvas.width = videoEl.videoWidth;
        canvas.height = videoEl.videoHeight;
        canvas.getContext('2d').drawImage(videoEl, 0, 0, canvas.width, canvas.height);
        const imageDataUrl = canvas.toDataURL('image/jpeg');
        const formData = new FormData();
        formData.append('session_id', INTERVIEW_SESSION_ID);
        formData.append('image_data', imageDataUrl);
            
        try {
            const response = await fetch("{% url 'verify_id' %}", { method: 'POST', body: formData });
            const result = await response.json();
            if (result.status === 'success') {
                statusEl.innerText = "Verification Successful! Starting interview...";
                statusEl.style.color = 'green';
                if (verificationStream) { verificationStream.getTracks().forEach(track => track.stop()); }
                
                setTimeout(() => {
                    document.getElementById('setup-phase').style.display = 'none';
                    if (spokenQuestions.length > 0) {
                        document.getElementById('spoken-interview-phase').style.display = 'flex';
                        runInterview();
                    } else {
                        startCodingPhase();
                    }
                }, 2000);
            } else {
                throw new Error(result.message || "Verification failed.");
            }
        } catch (err) {
            statusEl.innerText = `Error: ${err.message}`;
            statusEl.style.color = 'red';
        }
    }

    function runInterview() {
        const container = document.getElementById('question-container');
        container.innerHTML = `<p style="text-align:center; font-size: 1.2em;">Initializing proctoring camera... Please wait.</p>`;
        startProctoringMonitors();
    }

    function startFirstSpokenQuestion() {
        console.log("Starting first spoken question...");
        console.log("Spoken questions count:", spokenQuestions.length);
        console.log("Coding questions count:", codingQuestions.length);
        
        if (spokenQuestions.length > 0) {
            console.log("Starting spoken questions phase");
            nextSpokenQuestion();
        } else {
            console.log("No spoken questions, starting coding phase");
            startCodingPhase();
        }
    }

    function nextSpokenQuestion() {
        console.log("nextSpokenQuestion called, currentSpokenQuestionIndex:", currentSpokenQuestionIndex);
        if (interviewEnded) return;
        stopRecordingAndProcessing();
        clearTimeout(noAnswerTimeout);
        clearInterval(thinkingTimer); clearInterval(answeringTimer); clearInterval(reviewInterval);
        
        hasStartedSpeaking = false;
        silenceDetector.counter = 0;

        document.getElementById('thinking-timer').style.display = 'none';
        document.getElementById('answering-timer').style.display = 'none';
        document.getElementById('done-btn').style.display = 'none';
        document.getElementById('review-timer-display').style.display = 'none';

        currentSpokenQuestionIndex++;
        console.log("New currentSpokenQuestionIndex:", currentSpokenQuestionIndex);
        console.log("Total spoken questions:", spokenQuestions.length);
        
        if (currentSpokenQuestionIndex >= spokenQuestions.length) {
            console.log("All spoken questions completed, starting coding phase");
            startCodingPhase();
            return;
        }

        const q = spokenQuestions[currentSpokenQuestionIndex];
        console.log("Loading question:", q);
        document.getElementById('question-container').innerHTML = `<div id="question-category" class="question-category">${q.type}</div><p id="question-text" class="question-text">${q.text}</p>`;
        document.getElementById('transcription-box').innerHTML = "<span class='status-indicator status-loading'></span><i>The question will be read now...</i>";
        currentAudio.src = q.audio_url;
        console.log("Playing audio from:", q.audio_url);
        currentAudio.play().catch(e => console.error("Error playing question audio:", e));
        currentAudio.onended = () => {
            console.log("Audio ended, starting thinking phase");
            questionStartTime = new Date(); 
            startThinkingPhase();
        };
    }

    function startThinkingPhase() {
        if (interviewEnded) return;
        startRecordingAndMonitoring();
        let timeLeft = THINKING_TIME;
        const timer = document.getElementById('thinking-timer');
        timer.style.display = 'block';
        timer.innerText = `Time to think: ${formatTime(timeLeft)}`;
        thinkingTimer = setInterval(() => {
            timeLeft--;
            timer.innerText = `Time to think: ${formatTime(timeLeft)}`;
            if (timeLeft < 0) { 
                clearInterval(thinkingTimer);
                if (!hasStartedSpeaking) {
                    startAnswerGracePeriod();
                }
            }
        }, 1000);
    }

    function startAnswerGracePeriod() {
        if (interviewEnded || hasStartedSpeaking) return;
        document.getElementById('thinking-timer').style.display = 'none';
        document.getElementById('transcription-box').innerHTML = "<span class='status-indicator status-loading'></span><i>Please begin speaking now... You have 15 seconds.</i>";
        noAnswerTimeout = setTimeout(forceNextQuestion, 15000);
    }

    function forceNextQuestion() {
        if (interviewEnded || hasStartedSpeaking) return;
        clearTimeout(noAnswerTimeout);
        stopRecordingAndProcessing();
        moveNextAudio.play();
        moveNextAudio.onended = nextSpokenQuestion;
    }

    function startAnsweringPhase() {
        if (hasStartedSpeaking || interviewEnded) return;
        clearTimeout(noAnswerTimeout);
        hasStartedSpeaking = true;
        clearInterval(thinkingTimer);
        document.getElementById('thinking-timer').style.display = 'none';
        document.getElementById('transcription-box').innerHTML = "<span class='status-indicator status-loading'></span><i>Recording...</i>";
        let timeLeft = ANSWERING_TIME;
        const timer = document.getElementById('answering-timer');
        timer.style.display = 'block';
        document.getElementById('done-btn').style.display = 'block';
        answeringTimer = setInterval(() => {
            timer.innerText = `Time to answer: ${formatTime(timeLeft)}`;
            timeLeft--;
            if (timeLeft < 0) {
                moveToReviewPhase();
            }
        }, 1000);
    }

    function moveToReviewPhase() {
        if (interviewEnded) return;
        clearInterval(answeringTimer);
        clearTimeout(noAnswerTimeout);
        document.getElementById('answering-timer').style.display = 'none';
        document.getElementById('done-btn').style.display = 'none';
        stopRecordingAndProcessing();
    }
    
    function startReviewTimer() {
        if (interviewEnded) return;
        let timeLeft = REVIEW_TIME;
        const review = document.getElementById('review-timer-display');
        review.style.display = 'block';
        reviewInterval = setInterval(() => {
            review.innerText = `Next question in ${timeLeft}...`;
            timeLeft--;
            if (timeLeft < 0) { clearInterval(reviewInterval); nextSpokenQuestion(); }
        }, 1000);
    }
    
    async function startRecordingAndMonitoring() {
        if (interviewEnded) return;
        audioChunks = [];
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
            mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
            mediaRecorder.onstop = sendAudioToServer;
            mediaRecorder.start();
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            micSource = audioContext.createMediaStreamSource(stream);
            scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
            
            scriptProcessor.onaudioprocess = e => {
                const input = e.inputBuffer.getChannelData(0);
                let sum = 0.0;
                for (let i = 0; i < input.length; ++i) { sum += input[i] * input[i]; }
                const volume = Math.sqrt(sum / input.length);

                if (volume > 0.015) {
                    if (!hasStartedSpeaking) startAnsweringPhase();
                    if (hasStartedSpeaking) silenceDetector.counter = 0;
                } else {
                    if (hasStartedSpeaking) silenceDetector.counter++;
                }

                if (silenceDetector.counter > silenceDetector.threshold) {
                    if (!interviewEnded) {
                       moveToReviewPhase();
                       silenceDetector.counter = 0;
                    }
                }
            };
            micSource.connect(scriptProcessor);
            scriptProcessor.connect(audioContext.destination);
        } catch (err) {
            document.getElementById('transcription-box').innerHTML = `<span class="error">Microphone access denied.</span>`;
        }
    }

    function stopRecordingAndProcessing() {
        if (mediaRecorder && mediaRecorder.state === "recording") { mediaRecorder.stop(); }
        if (audioContext) { audioContext.close().catch(e => {}); audioContext = null; }
    }

    async function sendAudioToServer() {
        const box = document.getElementById('transcription-box');
        const blob = new Blob(audioChunks, { type: 'audio/webm' });
        if (blob.size < 1024) { box.innerHTML = "<i>No answer recorded.</i>"; startReviewTimer(); return; }
        box.innerHTML = "<i>Processing...</i>";
        const fd = new FormData();
        fd.append('audio_data', blob);
        fd.append('session_id', INTERVIEW_SESSION_ID);
        const currentQuestion = spokenQuestions[currentSpokenQuestionIndex];
        if (currentQuestion && currentQuestion.id) {
            fd.append('question_id', currentQuestion.id);
        }
        const responseTime = (new Date() - questionStartTime) / 1000;
        fd.append('response_time', responseTime);
        try {
            const res = await fetch("{% url 'transcribe_audio' %}", { method: 'POST', body: fd });
            if (!res.ok) { const err = await res.json(); throw new Error(err.error || `Server Error ${res.status}`); }
            const result = await res.json();
            box.innerHTML = `<span class='status-indicator status-success'></span><strong>Your Answer:</strong> ${result.text || "No speech was detected."}`;
            
            if (result.follow_up_question) {
                spokenQuestions.splice(currentSpokenQuestionIndex + 1, 0, result.follow_up_question);
            }
        } catch (err) {
            box.innerHTML = `<span class='status-indicator status-error'></span><span style="color: var(--danger-color);"><strong>Transcription Error:</strong> ${err.message}</span>`;
        } finally {
            startReviewTimer();
        }
    }

    function startCodingPhase() {
        console.log("Transitioning to coding phase...");
        stopRecordingAndProcessing();
        clearTimeout(noAnswerTimeout);
        clearInterval(thinkingTimer); clearInterval(answeringTimer); clearInterval(reviewInterval);

        if (codingQuestions.length === 0) {
            endSpokenOnlyInterview();
            return;
        }

        document.getElementById('spoken-interview-phase').style.display = 'none';
        document.getElementById('coding-interview-phase').style.display = 'block';
        nextCodingQuestion();
    }

    function nextCodingQuestion() {
        currentCodingQuestionIndex++;

        if (currentCodingQuestionIndex >= codingQuestions.length) {
            console.log("All coding challenges completed.");
            window.location.href = "{% url 'interview_complete' %}";
            return;
        }

        const codingQuestion = codingQuestions[currentCodingQuestionIndex];
        
        document.getElementById('coding-question-title').innerText = codingQuestion.title || 'Coding Challenge';
        document.getElementById('coding-language-display').innerText = `Language: ${codingQuestion.language}`;
        document.getElementById('coding-problem-text').innerText = codingQuestion.description || codingQuestion.text;
        document.getElementById('code-output-pre').innerHTML = "";

        const submitBtn = document.getElementById('submit-code-btn');
        if (currentCodingQuestionIndex === codingQuestions.length - 1) {
            submitBtn.innerText = "Submit & End Interview";
        } else {
            submitBtn.innerText = "Submit & Next Challenge";
        }
        submitBtn.disabled = false;

        if (!monacoEditor) {
            require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs' }});
            require(['vs/editor/editor.main'], function() {
                monacoEditor = monaco.editor.create(document.getElementById('monaco-editor-container'), {
                    value: `// Your ${codingQuestion.language} code here...`,
                    language: codingQuestion.language.toLowerCase(),
                    theme: 'vs-dark'
                });
            });
        } else {
            monacoEditor.setValue(`// Your ${codingQuestion.language} code here...`);
            monaco.editor.setModelLanguage(monacoEditor.getModel(), codingQuestion.language.toLowerCase());
        }

        const runBtn = document.getElementById('run-code-btn');
        const newRunBtn = runBtn.cloneNode(true);
        runBtn.parentNode.replaceChild(newRunBtn, runBtn);
        newRunBtn.addEventListener('click', () => runCode(codingQuestion));
        
        const newSubmitBtn = submitBtn.cloneNode(true);
        submitBtn.parentNode.replaceChild(newSubmitBtn, submitBtn);
        newSubmitBtn.addEventListener('click', () => submitCurrentCode(codingQuestion));
    }

    async function runCode(question) {
        const outputEl = document.getElementById('code-output-pre');
        outputEl.innerText = "Running...";
        const code = monacoEditor.getValue();

        const response = await fetch("{% url 'execute_code' %}", {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                code: code,
                language: question.language,
                question_id: question.id,
            })
        });
        const result = await response.json();
        
        let outputText = `Status: ${result.status.toUpperCase()}\n`;
        outputText += `${result.output || '(No output)'}`;
        outputEl.innerText = outputText;
    }

    async function submitCurrentCode(question) {
        const isFinalSubmission = (currentCodingQuestionIndex === codingQuestions.length - 1);
        const confirmationMessage = isFinalSubmission 
            ? "Are you sure you want to submit your code? This will end the interview."
            : "Are you sure you want to submit this answer and move to the next challenge?";
        
        if (!confirm(confirmationMessage)) return;

        const submitBtn = document.getElementById('submit-code-btn');
        submitBtn.disabled = true;
        submitBtn.innerText = "Submitting...";
        const code = monacoEditor.getValue();

        try {
            const response = await fetch("{% url 'submit_coding_challenge' %}", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_key: SESSION_KEY,
                    question_id: question.id,
                    code: code,
                    language: question.language,
                    is_final: isFinalSubmission
                }),
                keepalive: true
            });
            
            if (!response.ok) throw new Error("Server error during submission.");

            if (isFinalSubmission) {
                // Release media resources before redirecting
                releaseMediaResources();
                window.location.href = "{% url 'interview_complete' %}?session_key=" + SESSION_KEY;
            } else {
                nextCodingQuestion();
            }
        } catch (err) {
            alert("An error occurred. Please try again. Error: " + err.message);
            submitBtn.disabled = false;
            submitBtn.innerText = isFinalSubmission ? "Submit & End Interview" : "Submit & Next Challenge";
        }
    }

    function endSpokenOnlyInterview() {
        if (interviewEnded) return;
        interviewEnded = true;
        console.log("Ending spoken-only interview.");
        
        // Release media resources before ending session
        releaseMediaResources();
        
        fetch("{% url 'end_interview_session' %}", {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ session_key: SESSION_KEY }),
            keepalive: true
        })
        .catch(err => console.error("Error ending session:", err))
        .finally(() => {
            window.location.href = "{% url 'interview_complete' %}?session_key=" + SESSION_KEY;
        });
    }
    
    async function releaseMediaResources() {
        try {
            // Stop all media streams
            if (verificationStream) {
                verificationStream.getTracks().forEach(track => track.stop());
                console.log('Released verification stream');
            }
            
            // Stop media recorder
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                console.log('Stopped media recorder');
            }
            
            // Close audio context
            if (audioContext) {
                audioContext.close().catch(e => console.log('Audio context already closed'));
                console.log('Closed audio context');
            }
            
            // Clear all intervals and timeouts
            clearInterval(thinkingTimer);
            clearInterval(answeringTimer);
            clearInterval(reviewInterval);
            clearInterval(proctoringInterval);
            clearTimeout(noAnswerTimeout);
            clearInterval(terminationWarningInterval);
            
            // Release backend camera resources
            try {
                await fetch("{% url 'release_camera' %}", {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_key: SESSION_KEY })
                });
                console.log('Backend camera resources released');
            } catch (error) {
                console.log('Error releasing backend camera:', error);
            }
            
            console.log('All media resources released successfully');
        } catch (error) {
            console.log('Error releasing media resources:', error);
        }
    }

    function startProctoringMonitors() {
        const proctoringFeed = document.getElementById('proctoring-feed');
        console.log("Starting proctoring monitors...");
        
        proctoringFeed.onload = () => {
            console.log("Proctoring feed loaded successfully. Starting interview.");
            startFirstSpokenQuestion();
        };
        proctoringFeed.onerror = () => {
            console.error("Failed to load proctoring feed.");
            console.log("Attempting to start interview without proctoring feed...");
            // Start interview even if proctoring feed fails
            setTimeout(() => {
                startFirstSpokenQuestion();
            }, 2000);
        };

        const feedUrl = `/interview_app/video_feed/?session_key=${SESSION_KEY}&t=${new Date().getTime()}`;
        console.log("Loading proctoring feed from:", feedUrl);
        proctoringFeed.src = feedUrl;

        // Set a timeout to start interview even if proctoring feed doesn't load
        setTimeout(() => {
            if (document.getElementById('spoken-interview-phase').style.display === 'flex') {
                console.log("Proctoring feed timeout - starting interview anyway");
                startFirstSpokenQuestion();
            }
        }, 10000);

        proctoringInterval = setInterval(async () => {
            if(interviewEnded) return;
            try {
                const res = await fetch(`/interview_app/status/?session_key=${SESSION_KEY}`);
                const warnings = await res.json();
                if (warnings.no_person_warning_active) showTerminationWarning();
                else hideTerminationWarning();
                const list = document.getElementById('warnings-list');
                list.innerHTML = '';
                for (const [key, value] of Object.entries(warnings)) {
                    if (value === true && key.endsWith('_warning')) {
                        const li = document.createElement('li');
                        li.textContent = key.replace(/_/g, ' ').replace(' warning', '').toUpperCase();
                        list.appendChild(li);
                    }
                }
            } catch (e) {}
        }, 2500);
        document.getElementById('done-btn')?.addEventListener('click', moveToReviewPhase);
    }

    function showTerminationWarning() {
        if (isTerminationWarningVisible || interviewEnded) return;
        isTerminationWarningVisible = true;
        document.getElementById('termination-modal').style.display = 'flex';
        let timeLeft = TERMINATION_TIME;
        const timer = document.getElementById('termination-modal').querySelector('.timer-display');
        terminationWarningInterval = setInterval(() => {
            timer.innerText = `Terminating in: ${formatTime(timeLeft)}`;
            timeLeft--;
            if (timeLeft < 0) endSpokenOnlyInterview();
        }, 1000);
    }

    function hideTerminationWarning() {
        if (!isTerminationWarningVisible) return;
        isTerminationWarningVisible = false;
        clearInterval(terminationWarningInterval);
        document.getElementById('termination-modal').style.display = 'none';
    }

    function formatTime(s) {
        if (s < 0) s = 0;
        const m = Math.floor(s / 60); s %= 60;
        return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
</script>
</body>
</html>